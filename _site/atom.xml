<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Marlon Etheredge</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2024-10-08T23:46:20+02:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name></name>
   <email>website.flq0z@passmail.net</email>
 </author>

 
 <entry>
   <title>Warp shader</title>
   <link href="http://localhost:4000/2024/10/08/warp-shader"/>
   <updated>2024-10-08T00:00:00+02:00</updated>
   <id>http://localhost:4000/2024/10/08/warp-shader</id>
   <content type="html">&lt;p&gt;The previous version of this website featured a background that aligned with its retro aesthetic, created using a multi-pass GLSL shader.&lt;/p&gt;

&lt;p&gt;The effect can be seen below.&lt;/p&gt;

&lt;div class=&quot;shader&quot;&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;/assets/js/three.min.js&quot;&gt;&lt;/script&gt;
  &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;/assets/js/warp-shader.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;p&gt;Two shaders are used to create the effect: the first generates a “warp” effect by stepping through a noise function, while the second is a post-processing shader that adds jitter and chromatic aberration. This effect utilizes two render passes, with the “warp” shader rendering to a render target and the post-processing shader rendering to the default frame buffer using the previously generated render target.&lt;/p&gt;

&lt;h2 id=&quot;warp-effect&quot;&gt;Warp effect&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;varying vec2 UV;

uniform float Time;

uniform vec2 Resolution;

float noise(vec2 x) {
    return fract(sin(dot(x / 500.0, vec2(12.9898, 78.233))) * 43758.5453);
}

void main() {
    vec3 r = vec3(2.0 * (gl_FragCoord.xy - Resolution * 0.5) / Resolution, (sin(Time * 0.01) * 0.5 + 0.5) * 0.6 + 0.4);

    float o = Time * 0.08;

    vec3 c = vec3(0.0);
    vec3 s = r / max(abs(r.x), abs(r.y));
    vec3 p = 2.0 * s + 0.1;

    for (int i = 0; i &amp;lt; 20; ++i, p += s) {
        vec3 d = vec3(30.0 * fract(noise(round(p.xy)) - o) - p.z);
        c += max(vec3(0.0), vec3(0.9) - abs(d * vec3(0.76))) * d;
    }

    gl_FragColor = vec4(c, 1.0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;post-processing-effect&quot;&gt;Post-processing effect&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;varying vec2 UV;

uniform float Time;

uniform sampler2D Tex;

const vec2 randConst = vec2(12.9898, 78.233);

const float randMultiplier = 43758.5453;
const float smoothstepWidth = 0.02;
const float textureOffsets[3] = float[](0.010, 0.005, 0.000);

void main() {
    vec2 uv = UV;

    float smoothstepRange = 1.0 / 15.0;
    float smoothstepStart = smoothstepRange * (floor(Time * 0.5 / smoothstepRange));
    float smoothstepEnd = smoothstepStart + smoothstepRange;
    float smoothstepValue = smoothstep(smoothstepStart, smoothstepEnd, uv.y);

    float o = 0.01 * sin(1.0 - tan(Time * 0.005));

    uv.x += (smoothstepValue * o) - ((1.0 - smoothstepValue) * o);
    uv.x += fract(sin(dot(vec2(Time * 0.00001, floor(uv.y * 200.0) / 200.0), randConst)) * randMultiplier) * 0.005;

    vec4 texValue = vec4(0.0, 0.0, 0.0, 1.0);
    for (int i = 0; i &amp;lt; 3; ++i) {
        texValue[i] = texture(Tex, uv + vec2(textureOffsets[i], 0.0)).r;
    }
    texValue.w = 1.0;

    gl_FragColor = texValue;
}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>First post</title>
   <link href="http://localhost:4000/2024/10/08/first-post"/>
   <updated>2024-10-08T00:00:00+02:00</updated>
   <id>http://localhost:4000/2024/10/08/first-post</id>
   <content type="html">&lt;p&gt;I am the drive that ignites your search,&lt;br /&gt;
A force for knowledge, where ideas emerge.&lt;br /&gt;
I lead you to insights, theories, and facts,&lt;br /&gt;
What am I, if not the will to explore and act?&lt;/p&gt;
</content>
 </entry>
 

</feed>
